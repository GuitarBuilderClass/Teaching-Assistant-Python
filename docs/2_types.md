## データの扱い
### Pythonが扱う基本データ
- bool（真偽値)
    - `True`
    - `False`
- 数
    - int(整数)
        - `1`とか`2`とか、整数
        - 大きな数などで単位の区切りに`_`を使ってもいい
            - 最初と最後には`_`を置けない
            - `_`は連続してもいけない
    - float(浮動小数点数)
        - `3.1415`みたいなやつ
            - 浮動小数の仕組みは調べてください
            - コンピュータの中では数字を2進数で処理しているので表現できない小数がある
            - 私の環境だと0.01を10,000回足し合わせると`100.00000000001425`になりました
            - 仕事や競技プログラミングで引っ掛かる罠なので`decimal`という言葉を頭の隅に置いておくとあとで嬉しい
    - complex(複素数)
        - `(3 + 4j)`
            - `j`を後ろにつけると虚数になる
- str(文字列)
    - 'シングルクォーテーションで囲んだり'
    - "ダブルクオーテーションで囲んだり"
    - """ダブルクオーテーション3つで囲んだり"""
        - トリプルダブルクオーテーションで囲むものはクラスや関数を説明するコメント（後述）として使われる
    - 他の言語では1文字だけのChar型があったりするけど、Pythonでは1文字でも文字列
    - 普段は`"`ダブルクオーテーションで囲むのが良いと思う
    - 文字列の中で特殊な文字を使いたいときは前に`'\'`（バックスラッシュ）をつける
        - Windowsでは`¥`マーク
---
【実習】
ターミナルに`python`と入力するとPythonを試す環境が現れる  
- 文頭に`>>>`と書いてある行は入力行
- 文頭に`...`と書いてある行は入力がまだ続いている行
- 文頭に上2つの記号がなければ出力行

下記を入力して出力を確かめよう

1. 真偽値
    ```python
    >>> True
    True  
    ```

1. 数
   ```python
   >>> 50_000
   50000
   
   >>> 6_0_0
   600
   
   >>> 1.4142
   1.4142
   
   >>> 2_000j
   2000j
   
   >>> 9
   File "<input>", line 1
   9_
    ^
   SyntaxError: invalid token
   
   >>> 7__0
   File "<input>", line 1
   7__0
    ^
   SyntaxError: invalid token
   
   >>> 334_j
   File "<input>", line 1
   334_j
      ^
   SyntaxError: invalid token
   ```

    誤りがある場所を`^`で教えてくれる  
    `_`の使い方を間違うと`SyntaxError`(構文エラー)　その記号は無効だよ、と言われる  
    最初と最後や連続して`_`を使わなければいいので`6_0_0`は正しい構文として処理される  
    虚数も`j`の前が数なので`_j`と書くことはできない
    
1. 文字列
    ```python
    >>> "abc"
    'abc'
   
    >>> 'あいうえお'
    'あいうえお'
   
    >>> a = """QWERTY
    ... QWERTZ
    ... AZERTY
    ... DVORAK
    ... """
    >>> a
    'QWERTY\nQWERTZ\nAZERTY\nDVORAK\n'
   
    >>> ThisIsNotString
    Traceback (most recent call last):
    File "<input>", line 1, in <module>
    NameError: name 'ThisIsNotString' is not defined
    ```
    クオーテーションで囲んでいないものは文字列として扱われない  
    `NameError`(名前のエラー) 'ThisIsNotString' が定義されてないよ　　
    クオーテーションで囲んでいないものは後述する『変数』として扱われるため、未定義だと注意される

---    
### 変数: 名前を付けて記憶
ここまでの実習で入力したデータたちは再利用できない  
再利用するためにはデータに名前を付ける  
これを変数という

```python
>>> pi = 3.14

```
これで`pi`という変数（箱）に`3.14`という数が代入されたので、この数を何度でも再利用できる

```python
>>> pi
3.14

>>> pi
3.14
```

変数には再代入ができる  
その場合、新しい値がその変数と紐付けられて再利用できるようになる

```python 
>>> pi = "円周率" 
>>> pi
'円周率'

>>> pi
'円周率'
```
変数`pi`の値が`3.14`という`float`型から`'円周率'`という`str`型に再代入された

#### 名前付けのルール
Pythonにはコードの書き方（コーディングスタイル）に[PEP8](https://pep8-ja.readthedocs.io/ja/latest/)というガイドラインがある　  
そこには[変数名は小文字のみで、単語が続く場合は`_`で区切るべき](https://pep8-ja.readthedocs.io/ja/latest/#id35)という取り決めがある

```python
>>> good_variable_name = "良い変数名"

>>> badVariableName = "他の言語ではこういう名前の付け方をすることもあるよ"
```
実行しても特に問題なく動くけど、あとでコーディング規約チェックを自動で行う設定を使うとメッチャ怒られる  
窮屈に感じるかもしれないけれど、コーディングスタイルを決めていないプロジェクトで各人が好き勝手に書くと地獄  
言語レベルで決めてくれているのは良心的だと思う

---
### 演算子: 足したり引いたりくっつけたり
#### 数の話

|演算子|意味|例|結果|
|:---:|:---:|:---:|:---:|
|`+`|足し算|`1 + 3j`|(1+3j)|
|`-`|引き算|`33 - 4`|29|
|`*`|掛け算|`2 * 8`|16|
|`/`|float型で割り算|`5 / 2`|2.5|
| | | `4 / 2`|2.0|
|`//`|割り算の商(つまり切り捨て)|`5 // 2`|2|
|`%`|割り算の余り|`5 % 2`|1|
|`**`|べき乗|`-3j ** 2`|(9-0j)|
(メモ: 虚数`Ij`は2乗すると`-I`)になる

#### 文字列の話

|演算子|意味|例|結果|
|:---:|:---:|:---:|:---:|
|`+`|連結|`"a" + "b" + "c"`|'abc'|
|`*`|繰り返し|`"Spam" * 3`|'SpamSpamSpam'|

- ほぼ四則演算の優先順位通りに処理する
- `()`で囲むと優先度が高くなるのも四則演算と同じ

#### 再代入しながら計算
変数の後に続く`=`の前に演算子を付けると変数そのものに`=`後の処理を行う

```python
>>> n = 7
>>> n
7

>>> n += 5
>>> n
12

>>> n -= 3
>>> n
9

>>> s = "E" + "g" * 2
>>> s
'Egg'

>>> s *= n
>>> s
'EggEggEggEggEggEggEggEggEgg'
```

---
### コメント: 人間だけが読むもの
変数名や関数名、クラス名を読むだけで何をしているか説明できているコードが理想だが、込み入った動作を説明したいことがある  
コメントに該当する部分をPythonは認識しないが、人間が読むときに助けとなる

```python
>>> #　`#`ではじまる行はコメントなので無視される
>>> a = 33  #　+ 55　 `#`の後ろはコメントになって無視される
>>> a
33
```

変数に代入しなかったり、後述する`print()`関数で表示しなければ値は闇に葬り去られる  
```python
"""ソースコードを書くときは、変数に代入せずトリプルクオーテーションで囲んで説明を書くコメントスタイルもある"""
```

---
### まとめて扱う: リスト(`List`)・タプル(`Tuple`)・辞書(`Dict`)・集合(`Set`)
データをひとまとめに扱いたいことが多々ある  
この節ではPythonで使えるデータのまとめ方と扱い方を紹介する

Pythonにはイミュータブル（変更不可）とミュータブル（変更可）という属性がある  
- イミュータブルな型は再代入しない限り値を変更できない
- ミュータブルな型は再代入をしなくても値を変更できる

#### list(ミュータブル)
- 順番を維持してデータをまとめる
- 空のlistを宣言する方法は2つ
    - `lst = []`
    - `lst = list()`
- 最初から中身があるlistを宣言する方法は`[]`で囲んだ要素をカンマで区切る
    - `lst = [3, True, "Freedom"]`
        - 他の言語では同じ配列（Pythonのlist）には同じ型しか入れられないことがある
        - 言語上では制限がないが、`MyPy`を利用して似たような制限はできる (注: **バージョン3.5以上**)
            ```python
            >>> from typing import List, Any
            
            >>> int_list: List[int] = [1, 2, 3]
            >>> str_list: List[str] = ["spam", "hum", "egg"]
            >>> any_list: List[Any] = [True, 0, "nil"]
            >>> list_list: List[List[int]] = [[1, 2, 3],
                                              [4, 5, 6],
                                              [7, 8, 9],]                   
            ```
        - listの中にはlistを含めたこのあとで扱う基本データ型以外のものも入れられる（以下同様）
- listに要素を追加する方法は2つで、それぞれ少し挙動が違う
    ```python
    >>> plus_list = [1, 2]
    >>> plus_list
    [1, 2]
    
    >>> plus_list += [3]  # listに`+=`するとき直接1要素を入れることはできないので`[]`で囲んでいる
    >>> plus_list
    [1, 2, 3]
  
    >>> plus_list += [4, 5, 6]  # 後ろに繋げて追加する
    >>> plus_list
    [1, 2, 3, 4, 5, 6]
  
  
    >>> append_list = ["A", "B"]
    >>> append_list.append("C")  # `append()`するときは型を気にしなくていい
    >>> append_list
    ['A', 'B', 'C']
  
    >>> append_list.append(["D", "E", "F"])  # そのままの形で末尾へ追加する
    >>> append_list
    ['A', 'B', 'C', ['D', 'E', 'F']]
    ```
- まとめると以下の通り
    - `+=`: 要素すべてをひとつにまとめる
    - `list.append()`: 要素の形を保って末尾へ追加する

---
【実習】 次の順番で入力する前に最後の`answer`の中身を予想し、実際の出力結果を見て答え合わせする
```python
>>> answer = [2, 3, 5]
>>> a = [7, ]
>>> b = [11, 13]
>>> answer += a
>>> answer.append(b)
>>> answer
```

---   
#### tuple(イミュータブル)
- 順番を維持してデータをまとめる
- listとの違い
    - イミュータブルなので`append()`などができない
    - 消費メモリが少ない
    - 不用意に値を書き換えることがない安心感　など

##### シーケンスとスライス

#### dict（ミュータブル）
#### set        

### 変数の中身を表示させる: `print()`関数
